### Example 1: Majority Element ###

***Steps:***
1. From the given array, assume that starting index of the array , is my majority element.
2. From that start element compare rest of the elements , if you got same value -> increase the counter . If you got different value -> decrease the counter .
3. Counter becomes zero , it means , till now we haven't seen majority element . Again , select the new target element . the very next element would be your target element .
4. At the end of for loop if counter is more than zero , it means that there is a possibility of a majority element . 
5. Taking that target value, count how many times that element was repeated in the array . if counter is greater than n/2 than that's my majority element .

```
class Solution {
Â  Â  public int majorityElement(int[] nums) {
Â  Â  Â  Â  int target=nums[0];
Â  Â  Â  Â  int cnt = 1;

Â  Â  Â  Â  for(int i = 1; i<nums.length ; i++){
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  if(cnt==0){
Â  Â  Â  Â  Â  Â  Â  Â  target=nums[i];
Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  if(nums[i]==target){
Â  Â  Â  Â  Â  Â  Â  Â  Â cnt++;
Â  Â  Â  Â  Â  Â  } else{
Â  Â  Â  Â  Â  Â  Â  Â  cnt--;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }

Â  Â  Â  Â  int temp=0;
Â  Â  Â  Â  if(cnt>0){
Â  Â  Â  Â  
Â  Â  Â  Â  Â  Â  for(int i=0 ; i<nums.length ; i++){

Â  Â  Â  Â  Â  Â  Â  Â  if(nums[i]==target){
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  temp++;
Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  if(temp>(nums.length/2)) return target;
Â  Â  Â  Â  }

Â  Â  Â  Â  return 0;
Â  Â  }
}
```




### Example 2: Longest Consecutive Sequence ###

***Steps:***
1. Create a set 
2. Run a loop , take the values from array and push it into the set using `insert()` method.
3. Start iterating the set values , we have to find whether the element is the start element or not , by decreasing the value , and by checking if that value is there in the set or not.
4. If we got that start value , then start comparing , by incrementing and checking for that value and incrementing the count value .
```
class Solution {

Â  Â  public int longestConsecutive(int[] nums) {

Â  Â  Â  Â  int max_cnt = 0;

  

Â  Â  Â  Â  HashSet<Integer> h = new HashSet<>();

Â  Â  Â  Â  //inserting array elements into the set

Â  Â  Â  Â  for(int i = 0 ; i<nums.length ; i++){

Â  Â  Â  Â  Â  Â  h.add(nums[i]);

Â  Â  Â  Â  }

  

Â  Â  Â  Â  if(h.isEmpty()){

Â  Â  Â  Â  Â  Â  return 0;

Â  Â  Â  Â  }

  

Â  Â  Â  Â  for(int val : h){

Â  Â  Â  Â  Â  Â  if(!h.contains(val-1)){

Â  Â  Â  Â  Â  Â  Â  Â  int start = val;

Â  Â  Â  Â  Â  Â  Â  Â  int cnt = 1;

Â  Â  Â  Â  Â  Â  Â  Â  while(h.contains(start+cnt)){

Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  cnt++;

Â  Â  Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  Â  Â  max_cnt=Math.max(cnt,max_cnt);

  

Â  Â  Â  Â  Â  Â  }

  

Â  Â  Â  Â  }

  

Â  Â  Â  Â  return max_cnt;

Â  Â  }

}
```
**Practice**
LC: 239 & 209



---


### ðŸ§ `SubArray , SubSet , SubSequence , SubString ` 

| Term            | Type         | Must Be Contiguous? | Must Keep Order? | Example (`[1, 2, 3]`) |
| --------------- | ------------ | ------------------- | ---------------- | --------------------- |
| **Subarray**    | Array        | âœ… Yes               | âœ… Yes            | `[1,2]`, `[2,3]`      |
| **Subset**      | Set/Array    | âŒ No                | âŒ No             | `[1,3]`, `[2]`        |
| **Subsequence** | Array/String | âŒ No                | âœ… Yes            | `[1,3]`, `[1,2,3]`    |
| **Substring**   | String       | âœ… Yes               | âœ… Yes            | `"lo"` in `"hello"`   |

## ðŸ“¦ Subarray

- ðŸ”— **Contiguous chunk** of an array.
    
- ðŸ± Keeps the order.
    
- ðŸŽ¯ Total of `n*(n+1)/2` possible subarrays.


## ðŸŒˆ Subset

- ðŸ§® Any **combination** of elements (contiguous or not).
    
- âŒ Order doesnâ€™t matter.
    
- ðŸ’¡ Total = `2^n` subsets including empty set.


## ðŸ§µ Subsequence

- ðŸŒŠ A sequence that **maintains order** but **can skip elements**.
    
- ðŸ§  Think: pick & choose, but left to right only.
    
- Also `2^n` possibilities (excluding or including each item).


## ðŸ§¬ Substring

- ðŸ§£ A **contiguous chunk of a string**.
    
- ðŸ“ Order is preserved, characters are adjacent.
    
- Total substrings: `n*(n+1)/2`.

